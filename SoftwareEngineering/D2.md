

1、四种寻址方式

立即寻址方式:操作数就包含在指令中。作为指令的一部分，跟在操作码后存放在代码段。

这种操作数成为立即数。立即数可以是8位的，也可以是16位的。

 

寄存器寻址方式:操作数在CPU内部的寄存器中，指令指定寄存器号。对于16位操作数，寄存器可以是:AX、BX、CX、DX、SI、DI、SP和BP等。对于8位操作数，寄存器可以是AL 、AH、BL、BH、CL、CH、DL、DH。这种寻址方式由于操作数就在寄存器中，不需要访问存储器（比如内存）来取得操作数，因而可以取得较高的运算速度。

 

## 直接寻址方式:***\*指令\****所要的操作数存放在内存中，在指令中直接给出该操作数的有效地址，这种寻址方式为直接寻址方式。在通常情况下，操作数存放在数据段DS中，所以，其物理地址将由数据段寄存器DS和指令中给出的有效地址直接形成，但如果使用段超越前缀，那么，操作数可存放在其它段。

## 寄存器间接寻址方式:操作数在寄存器中，操作数有效地址在SI、DI、BX、BP这四个寄存器之一中。在不使用段超越前缀的情况下，如果有效地址在SI、DI和BX中，则以DS段寄存器中的内容为段值。如果有效地址在BP中，则以SS段寄存器中的内容为段值。

寄存器相对寻址方式:操作数在存储器中，操作数的有效地址是一个基址寄存器(BX、BP)或变址寄存器(SI、DI)的内容加上指令中给定的8位或16位位移量之和。

 

基址加变址寻址方式:操作数在寄存器中，操作数的有效地址由:基址寄存器之一的内容与变址寄存器之一的内容相加

 

相对基址加变址寻址方式：操作数在存储器中，操作数的有效地址由于基址寄存器之一的内容与变址寄存器之一的内容及指令中给定的8位或16位位移量相加得到。

 

2、进制转换

小数点前的采用除二取余法，小数点后的采用乘二取整数法

小数点前的一起除2，每次拿余数，然后从下到上排列。小数点后的每次*2，直到乘尽等于1为止，从上到下排列。

 

3、码制转换

对于正整数，原反补相同。 码位为1，原码1+二进制，反码1+二制制取反，补码1+反码，注意，先算原补反，然后前面再+1。

 

4、奇偶校验

最简单：奇校验，算上校验码有奇数个1。偶校验，算上校验码有偶数个1。注意老师可能让把校验位放在原数值前后的问题

 

5、标准单精浮点数

简单点，先把10进制转换为二进制，小数点前除2取余，从下到上排列。小数点后乘2取整，直到乘完等于1.0为止，有时候乘不尽，如0.11，小数位典型乘不尽，乘多少次都不会等于1的，取四位即可，小数位从上往下取。 

得到二进制后，如110001.11111，小数点前移直到小数点前只有1位，1.1000111111，向前移了整数位减1位，即5位。5+127=132D ，132D转换成二进制 ，替换掉移位后的整数位1。也就是132D=1000010，再加上0.1000111111= 1000010.10000111111，数下小数点位后的，用0补足23位。

 

6、海明码

首先记住，校验位为1，2，4，8，16，32....，一直乘以2的位。然后列个表格，先把校验位用P1~Pn补上，如老师说的1110的海明码。请注意，我是从后往前的

| H7   | H6   | H5   | H4   | H3   | H2   | H1   | 位置   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ------ |
| D4   | D3   | D2   |      | D1   |      |      | 信息位 |
|      |      |      | P3   |      | P2   | P1   | 校验位 |

 

然后将H1到H7的位置，比如H1是1,H5是5，转换成二进制。再做一个表格，将位置的二进制

| 0111 | 0110 | 0101 | 0100 | 0011 | 0010 | 0001 | 位置   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ------ |
| D4   | D3   | D2   |      | D1   |      |      | 信息位 |
|      |      |      | P3   |      | P2   | P1   | 校验位 |

 

再把信息位和校验位合并，并且我们是已经知道D1~D4的值的，填进去

| 0111 | 0110 | 0101 | 0100 | 0011 | 0010 | 0001 | 位置 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 1    | 1    | P3   | 0    | P2   | P1   | 值   |

 

这时候我们就差P1~P3的值不知道了，算了P1到P3，就知道校验码是多少了

P1的位置是0001，最后一位是1，看一下其它所有的位置，哪些位置的二进制值的最后一位是1， 第三位、第五位，第七位。将这三位的值取出，与p1异或等于0。下面用^表示异或。

P1=> P1^0^1^1=0

 =>P1^0=0

 =>P1=0

P2的第二位是1，看下其它位哪些第二位是1，取值异或=0

P2=>P2^0^1^1=0

 =>P2=0

P3的第三位是1，看下其它位哪些第三位是1，取值异或=0

P3=>P3^1^1^1=0

 =>P3=1

 

P3P2P1=100 

海明码=1110+100 = 1110110

注意这里面的+都是连接符，不是数值相加

 

7、计算多项式

以老师的例子为准，计算信息多项式：101010110，生成多项式：1100的CRC校验码

我们先看1100是几位，是4位，那么在101010110后面加上4-1个0，即三个0，最后得到101010110+000=10101011000

然后采用二进制的除法去除，这个除法没有借位，只有后面的位数够不够，不够就除不尽，够了就能拉着往下除。每除一次，抛弃前面为零的值，向后补足4位，接着往下除，直到除不尽，即后面没有位数补足，已经不足四位了，这个数就是校验码。

（只要能除尽，就是1。向后补足，如果补了一位不够，那就再补一位，前面的那位就是0）

 

![img](file:///C:\Users\meiyo\AppData\Local\Temp\ksohtml10580\wps1.png) 

 

如何验证这个值是否正确，就去拿多项式1100去按照上面方式去除，除的尽就是正确的，除不尽就是错的。 但也有特殊情况，算成了10、110、11、1，这些好像也没错，也是除的尽的。