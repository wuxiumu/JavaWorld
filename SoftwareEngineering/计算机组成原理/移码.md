如何计算原码、反码、补码、移码？

**真值->原码->反码->补码->移码**

https://blog.csdn.net/a470271804/article/details/85138782

- 原码
  - 定点整数
    若定点整数的原码形式位xnxn−1⋅⋅⋅x1x0,其中xn为符号位，则原码表示的定义为： 在上式中，x代表的是真值。 例如，x=+7,化为二进制表示为x=+0111;x[原]=0111原。 x=−7,化为二进制表示为x=−0111;x[原]=23−(−0111)=1000+0111=1111原。 我们可以总结出来： 1. 对于正数x=+xn−1...x1x0,它的原码是它自己 …
  - 定点小数
    假设定点小数的原码形式为xs.x1x2...xn(实际上小数点是不存储的),其中xs代表符号位。则原码的定义为： 在上式中，x代表的是真值。 例如，x=+0.875,化为二进制表示为x=+0.111;x[原]=0.111原。 x=−0.875二进制表示为x=−0.111;x[原]=1.000−(−0.111)=1.000+0.111=1.111原。 我们可以总结出来： 1. 对于正数x=+…
  - 原码的计算
    ​ 原码虽然表示极为简单，但是最大的问题就是加法运算十分复杂。 两数相加时，我们需要考虑两个数的符号，如果符号相同，我们可以把数值位直接相加，然后在最高位前边添加上原来的符号位。但如果符号位不相同，那么我们就要考虑进行减法运算。进行减法的时候，我们需要考虑数值位的绝对值大小来决 
- 反码
  - 当进行减法的时候，人们想到如何把减法变为加法，那么这样会更加简便，只靠加法器就可以完成运算。比如 1−1=0 0001−0001=0000 1+(−1)=0 0001+1001=1010=−2 显然是计算错误的。 于是人们引入了反码来表示负数。
- 补码
  - 补码的由来
    为了解决原码的计算问题，人们引入了补码。 我们先从时钟的例子来介绍补码的原理。 比如我们将定在五点的钟表跳到三点，有2种调法： 我们既可以顺时针调也可以逆时针调。也就是说我们5−2和5+10的效果是一样的。 而把这种思想引入到计算机中，不就可以把减法转为加法了吗？ 在上面的式子中，在模为1…
  - 定点整数
    定点整数的补码形式为xnxn−1⋅⋅⋅x1x0,其中xn为符号位，补码表示的定义为： 在上式中，x代表的是真值。 例如，x=+7,化为二进制表示为x=+0111;x[补]=0111。 x=−7,化为二进制表示为x=−0111;x[补]=24+(−0111)=10000−0111=1001。 我们可以总结出来： 1. 对于正数x=+xn−1...x1x0,它的补码是它自己 …
  - 定点小数
    定点小数的补码形式为xs.x1x2...xn(实际上小数点是不存储的),其中xs代表符号位。则补码的定义为： 在上式中，x代表的是真值。 例如，x=+0.875,化为二进制表示为x=+0.111;x[补]=0.111。 x=−0.875二进制表示为x=−0.111;x[补]=10.000−(0.111)=1.001。 我们可以总结出来： 1. 对于正数x=+0.xn−1...x1x0,它的补 …
- 移码
  - 移码通常用于表示浮点数的阶码。由于阶码是k位的整数，假设定点整数移码形式为ekek−1...e2e1e0最高位为符号位是。移码的传统定义是： [e]移=2k+e 上式中，e为真值，2k为固定的偏移值常数。 与[x]补的区别：符号位相反