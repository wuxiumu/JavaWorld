**[IEEE](https://baike.baidu.com/item/IEEE)****二进制浮点数算术标准**（**IEEE 754**）是20世纪80年代以来最广泛使用的[浮点数](https://baike.baidu.com/item/浮点数)运算标准，为许多[CPU](https://baike.baidu.com/item/CPU)与[浮点运算器](https://baike.baidu.com/item/浮点运算器)所采用。这个标准定义了表示浮点数的格式（包括负零[-0](https://baike.baidu.com/item/-0)）与反常值（denormal number）），一些特殊数值（[无穷](https://baike.baidu.com/item/无穷)（Inf）与非数值（NaN）），以及这些数值的“浮点数运算符”；它也指明了四种数值舍入规则和五种例外状况（包括例外发生的时机与处理方式）。

# 组成

IEEE754标准包含一组实数的二进制表示法。它有三部分组成：

- 符号位
- 指数位
- 尾数位

三种精度的浮点数各个部分位数如下：

![img](https://upload-images.jianshu.io/upload_images/6168671-312e36afb3732d9b.png?imageMogr2/auto-orient/strip|imageView2/2/w/395/format/webp)

# 正规化

对于将某个实数表示为计算机浮点数，首先要将其**正规化**，也就是表示为形如：
![\pm1.bbbb\cdots\times 2^p](https://math.jianshu.com/math?formula=%5Cpm1.bbbb%5Ccdots%5Ctimes%202%5Ep)

的样子。其中`b`是`0`或`1`，而`p`二进制数表示的指数位。这样，假设想表示为单精度(float)的浮点数，那么：

- 第一位符号位用`0`表示正，用`1`表示负
- 将指数`p`加上**移码**表示为8位的二进制数
- 在接下来的23位填充位数`b`部分。由于正规化表示时，最左边部分**总是**`1`，所以我们只需表示23位的尾数即可。

#### 移码

上述中有一个词：**移码**（exponential bias）。因为指数`p`有正有负，那么在8位的指数位中我们就要拿出第一位来**指示符号**，这样显然会造成不必要的浪费。给指数加上移码，就能保证结果**总是**一个非负数，也就可以将8个指数位都利用起来。对于有`M`个指数位的精度，其移码为：

![2^{M-1}-1](https://math.jianshu.com/math?formula=2%5E%7BM-1%7D-1)
 这样就得到上面三种精度的移码：



![img](https:////upload-images.jianshu.io/upload_images/6168671-3c2b392180821b44.png?imageMogr2/auto-orient/strip|imageView2/2/w/596/format/webp)


 以双精度(Double)的为例。双精度的指数位有11位。这样可以表示的数是从`000 0000 0000`到`111 1111 1111`，也就是*指数加移码*所表示的范围从0到2047，那么，减去移码1023，则可以表示的指数是-1023到1024。但是注意，**-1023和1024作为他用**（后面会说到）。所以**实际**上能表示数的指数是从-1022到1023。



#### 例子

> 【例】：求3.14的单精度浮点数表示。
>  首先将3.14转成二进制:
>
> - 整数部分3的二进制是11`b`
> - 小数部分0.14的二进制是：0.0010001111010111000**010**[10001111.....]`b`（方括号中表示小数点后第23位及之后）。
>
> 这样，3.14的二进制代码就是：11.0010001111010111000**010**[10001111....]×20`b`，那么用正规化表示就是：1.10010001111010111000**010**[10001111....]×21`b`。
>  方括号表示的就是小数点后第24位了，由于单精度浮点数尾数只有23位，所以需要**舍入**（舍入方法见后）：由于第24位为1，且之后 *不全为* 0，所以需要向第23位进1完成上舍入：1.10010001111010111000**011**×21`b`。
>  而其指数是1，需要加上移码127，即128，也就是(1000 0000)`b`。
>  它又是正数，所以符号为0。
>  综上所述，3.14的单精度浮点数表示为：
>  **0 1000-0000 1001-0001-1110-1011-1000-011**`b`
>  十六进制代码为：**0x4048F5C3**

通过此例可知，3.14的单精度浮点数表示是`0 1000-0000 1001-0001-1110-1011-1000-011`。现在我们来还原，看看它的误差：

- 指数是128，那么还原回去（减去移码），实际指数就是1
- 尾数还原也就是：10010001111010111000011`b`，所以是：1.10010001111010111000011×21`b`，也就是11.0010001111010111000011`b`。

利用二进制转十进制，可得它对应的十进制数是：**3.1400001049041748046875**。显然与3.14是有误差的。

我们再通过另一种方法估算误差。从例子中可知，对于3.14的单精度浮点数，我们舍去了第24位以及之后，它们是：
 0.00...(23个0)....00 **[10001111.....]×21**`b`。
 为了方便计算，不妨假设此后全是0（即方括号中省略部分），也就是舍去了：
 **0.10001111b×2-23×21**`b`
 约为0.00000013317912817001；由于舍入进位关系，给第23位又加了1，所以加了：2-23×21，故而要减去这一部分。
 所以，误差约为2-23×21 - 0.10001111b×2-23×21=0.00000010523945093155。所以结果大致为3.14+0.00000010523945093155=`3.14000010523945093155`。
 可见和上面计算结果大致相同。

#### 机器ε（machine epsilon）

机器ε表示1与大于1的最小浮点数之差。不同精度定义的机器ε不同。以双精度为例，双精度表示的1是：

![img](https:////upload-images.jianshu.io/upload_images/6168671-f1a58d7d96a0ac6b.png?imageMogr2/auto-orient/strip|imageView2/2/w/903/format/webp)



而比1大的最小双精度浮点数是：



![img](https:////upload-images.jianshu.io/upload_images/6168671-9b34b26cc3f16b0a.png?imageMogr2/auto-orient/strip|imageView2/2/w/912/format/webp)


 可见，此二者之差为：2-52≈2.220446049250313e-16。所以它就是双精度浮点数的机器ε。
 在舍入中，相对舍入误差不能大于机器ε的一半。比如上面的3.14的单精度浮点数，二者误差绝对值是0.0000001049041748046875....，从而相对舍入误差为0.0000001049041748046875....÷3.14≈`0.00000003340897286773`。而单精度浮点数的机器ε为2-23≈1.1920928955078125e-7，它的一半是`0.00000005960464477539`。显然，相对舍入误差小于单精度浮点数机器ε的一半。



# 非正规化：0的表示

从正规化中可知，**无论如何**浮点数都满足最左边是1。这就有一个严重问题：0没有办法被表示。为此，可以使用**非正规化**的表示方法，即让最左边默认为0，这样再另尾数也全部为0，就可以表示0了。

新的问题又来了：**根据什么**判断是非正规化还是正规化呢？

答案就是通过**指数部分**来反映。记得前面说过，双精度浮点数中，*指数加移码* 的范围可以从0到2047，然而0和2047是作为他用的。在这里，**指数部分为0就代表着非正规化**。

所以，当见到指数部分为0是，尾数部分就不再是`1.bbbbb...`而是`0.bbbbb...`了。
 再进一步，对于非正规化，可以看成是正规化中，小数点向**左边**跑了一位：1.bbbb....×2-1023=0.1bbbb....×2×2-1023==0.1bbbb....×2-1022（只是概念上理解，小数第一位也不一定非要是1，如`0.001010×2^-1022`也可）。所以，非正规化下表示为：

![img](https:////upload-images.jianshu.io/upload_images/6168671-c281681929f7a49e.png?imageMogr2/auto-orient/strip|imageView2/2/w/343/format/webp)



现在，0就可以表示了。值得注意的是，此时0可以表示位+0和-0。

因为它的最左边不是1是0，实际上可以表示更小的数。双精度浮点数下，使用非正规化可以表示的**最小的正数**是0.00......01×2-1022也就是2-52×2-1022=**2-1074**。

请注意这个最小数和前面提到的机器ε的**区别**。比机器ε小的数是可以被表示出来的（利用非正规化）。但是当它们与其他浮点数做运算时，因为要转成同一种格式（正规化格式），从而可能会因为溢出位而被舍弃。最终结果就是，这些更小的数尽管能被表示，但是对运算结果没有影响。

> **浮点数加法**
>  机器加法要先将两个操作数的小数点对齐，相加后再转为浮点数存储。这里最重要的一点是，尽管浮点数有位数限制，但是加法会在精度更高的寄存器中进行，这意味着，寄存器能够运算出比52位还要多的位数，但是在转回浮点数存储时，多余位数会被舍弃，造成两者相加的机器结果不严格等于算术结果。
>
> ![img](https:////upload-images.jianshu.io/upload_images/6168671-6ec09a516e053760.png?imageMogr2/auto-orient/strip|imageView2/2/w/1133/format/webp)
>
> ![img](https:////upload-images.jianshu.io/upload_images/6168671-a39fa83930d3c365.png?imageMogr2/auto-orient/strip|imageView2/2/w/1123/format/webp)

# 无穷大与NaN

上面说到，在双精度浮点数中，指数为0表示非正规化，那么指数为2047（二进制是111 1111 1111b，即11位指数位全为1）就表示无穷大和NaN（Not a Number）。具体表现在，当指数是2047，当尾数,全为0就表示无穷大，当尾数不全为0就表示NaN。

# 舍入规则

以52位尾数位的双精度浮点数为例，舍入时需要重点参考第53位：

- 若第53位为1，而第53位之后全部为0。此时就要使第52位为0：若第52位本来就是0则不管，若第52位为1，则第53位就要向第52位进一位，这样第52位就可以为0
- 若不是上面的情况，即第53位1，但是第53位之后不全为0，则第53位就要向第52位进一完成上舍入。
- 若也不是上面两种情况，那么第53位必为0，此时直接舍去不进位，称为下舍入。

由于存在这种舍入规则，浮点数一般在机器内都不会以原数精确相等的存储，这就会使在某些情况下，使用浮点数做算术运算时出现令人费解的情况，如在JavaScript中（数以双精度存储）：



```cpp
>>9.4-9-0.4===0 //9.4减去9再减去0.4，与0比较大小
<<false
>>(9.4-9-0.4).toFixed(20)
<<"0.00000000000000033307"
```

可见机器表示中，9.4-9-0.4**不严格等于**0，其结果有极小误差。因为按照上面的算法可知，9.4在机器内被表示为：9.4+0.2×2-49，而0.4被表示为0.4+0.1×2-52。这样，当9.4-9时（因为9是整数是可以精确存储的）得0.4+0.2×2-49，再减去0.4+0.1×2-52得3×2-53，约等于"0.00000000000000033307"。

> **循环小数的二进制转回十进制的技巧**
>  某循环小数的二进制码是：0. 0110 0110 0110 0110 0110.....b。可见是0110的循环，令x为其十进制数：x=0.01100110.....b，则24x=110,01100110.....b，两式相减得：(24-1)x=110b，即15x=6，从而x=6/15=0.4



作者：Azur_wxj
链接：https://www.jianshu.com/p/e5d72d764f2f
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。