1. 瀑布模型 

   1. 本质： 软件开发模型 ，瀑布模型将软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等六个基本活动，并且规定了它们自上而下、相互衔接的固定次序
   2. 特点：1、阶段间具有顺序性和依赖性 2、推迟实现的观点
   3. 优点：
      1. 为项目提供了按阶段划分的检查点 
      2.  当前一阶段完成后，您只需要去关注后续阶段 
      3. 可在迭代模型中应用瀑布模型
   4. 缺点：
      1.  不适合需求模糊或需求经常变动的系统 
      2. 由于开销的逐步升级问题，它不希望存在早期阶段的反馈  
      3. 在一个系统完成以前，它无法预测一个新系统引入一个机构的影响
   5. 概述： 开发是线性的，缺乏灵活性，文档复杂，工作量大， 早起错误后期测试才能发现

2. 原型模型 

   1. 本质：1、思想产生 在需求分析阶段得到完全、一致、准确、合理的需求说明十分困难 获得一组基本需求说明后，就快速地使其“实现”，通过原型反馈，加深对系统的理解满足用户基本要求，使用户在试用后对需求说明进行补充和精确化，从而获得合理完整、现实可行的需求说明 特点：
   2. 优点： 
      1. 克服瀑布模型的缺点，减少由于软件需求不明确带来的开发风险 
      2. 适合预先不能确切定义需求的软件系统的开发 
   3. 缺点：
      1.  所选用的开发技术和工具不一定符合主流的发展；快速建立起来的系统结构加上连续的修改可能会导致产品质量低下 
      2. 使用前提是要有一个展示性的产品原型，一定程度上可能会限制开发人员的创新
   4. 概述：制定系统原型，适用前期需求不明确，随着开发进行更改开发实现，适应需求有变化。 优点： 得到比较好的需求定义， 有利于开发培训同步，开发费用低，开发周期短。缺点： 过程不可见， 系统构造不合理， 需要使用特殊的开发工具。 客户端与开发理解不同，准确的原型设计困难。

3. 增量模型 

   1. 本质：成和测试。每个构件由多个相互作用的模块构成，并且能够完成特定的功能 使用增量模型时，第一个增量构件往往实现软件的基本需求，提供最核心的功能 把软件产品分解成增量构件时，唯一必须遵守的约 	
   2. 特点：把瀑布模型的顺序特征与快速原型法的迭代特征相结合 将软件看作一系列相互联系的增量，在开发过程的各次迭代中，每次完成其中的一个增量
   3. 优点：
      1. 能在较短的时间内向用户提交可完成部分工作的产品 
      2. 将待开发的软件系统模块化，可以分批次地提交软件产品，使用户可以及时了解软件项目的进展 
      3. 以组件为单位进行开发降低了软件开发的风险。一个开发周期内的错误不会影响到整个软件系统 
      4. 开发顺序灵活。
   4. 缺点：
   5. 概述：使用已有产品升级

4. 螺旋模型 

   1. 本质：螺旋模型是一种演化软件开发过程模型，它兼顾了快速原型的迭代特征以及瀑布模型的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。同时，在每个迭代阶段构建原型是螺旋模型用以减小风险的途径 螺旋模型是快速原型模
   2. 特点：螺旋模型在“瀑布模型”的每一个开发阶段前引入一个非常严格的风险识别、风险分析和风险控制，它把软件项目分解成一个个小项目。每个小项目都标识一个或多个主要风险，直到所有的主要风险因素都被确定 螺旋模型强调风险分析，使得开发人员和用户对每个演化层出现的风险有所了解，继而做出应有的反应
   3. 优点： 
      1. 对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标 
      2. 减少了过多测试（浪费资金）或测试不足（产品故障多）所带来的风险 
      3. 在螺旋模型中维护只是模型的另一个周期，在维护和开发之间并没有本质区别
   4. 缺点：
   5. 概述：增加风险分析阶段

   

1. 什么是面向对象？
   1. 面向对象是一种思想，是基于面向过程而言的，就是说面向对象是将功能等通过对象来实现，将功能封装进对象之中，让对象去实现具体的细节；这种思想是将数据作为第一位，而方法或者说是算法作为其次，这是对数据一种优化，操作起来更加的方便，简化了过程
   2. 总结
      1. 抽象会使复杂的问题更加简单化。
      2. 从以前面向过程的执行者，变成了张张嘴的指挥者。
      3. 面向对象更符合人类的思维，面向过程则是机器的思想
   3. 面向对象的三大特性
      1. 封装 隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。 
      2. 继承 提高代码复用性；继承是多态的前提。 
      3. 多态 父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。
   4. 五大基本原则
      1. 单一职责原则SRP(Single Responsibility Principle) 类的功能要单一，不能包罗万象，跟杂货铺似的。
      2. 开放封闭原则OCP(Open－Close Principle) 一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。 
      3. 里式替换原则LSP(the Liskov Substitution Principle LSP)
         子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~
      4. 依赖倒置原则DIP(the Dependency Inversion Principle DIP)
         高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。
      5. 接口分离原则ISP(the Interface Segregation Principle ISP)
         设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。
2. 什么是对象，什么是类？
   1. 类的概念：类是具有相同属性和服务的一组对象的集合。它为属于该类的所有对象提供了统一的抽象描述，其内部包括属性和服务两个主要部分。在面向对象的编程语言中，类是一个独立的程序单位，它应该有一个类名并包括属性说明和服务说明两个主要部分。 
   2.  对象的概念：对象是系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位。一个对象由一组属性和对这组属性进行操作的一组服务组成。从更抽象的角度来说，对象是问题域或实现域中某些事物的一个抽象，它反映该事物在系统中需要保存的信息和发挥的作用；它是一组属性和有权对这些属性进行操作的一组服务的封装体。客观世界是由对象和对象之间的联系组成的。类与对象的关系就如模具和铸件的关系，类的实例化结果就是对象，而对一类对象的抽象就是类。
   3. 类描述了一组有相同特性（属性）和相同行为（方法）的对象。上面大概就是它们的定义吧，也许你是刚接触面向对象的朋友，
      不要被概念的东西搞晕了，给你举个例子吧，如果你去中关村想买几台组装的PC
      机，到了那里你第一步要干什么，是不是装机的工程师和你坐在一起，按你提供的信息和你一起完成一个装机的配置单呀，这个配置单就可以想象成是类，它就是一张纸，但是它上面记录了你要买的PC
      机的信息，如果用这个配置单买10 台机器，那么这10 台机子，都是按这个配置单组成的，所以说这10
      机子是一个类型的，也可以说是一类的。那么什么是对象呢，类的实例化结果就是对象,用这个配置单配置出来（实例化出来）的机子就是对象，是我们可以操作的实体，10
      台机子，10 个对象。每台机子都是独立的，只能说明他们是同一类的，对其中一个机做任何动作都不会影响其它9
      台机器，但是我对类修改，也就是在这个配置单上加一个或少一个配件，那么装出来的9 个机子都改变了，这是类对象的关系(类的实例化结果就是对象)。
3. UML，UML图形化表示方法
   1.  
   2. 
4. UML行为事物，分组事物，UML关系， （关联关系，泛化关系）
   1.  
   2. 
5. 用例图，顺序图
   1.  
   2. 

10个选择、10个判断、6个大题（所有作业题）

1、瀑布模型， 开发是线性的，缺乏灵活性，文档复杂，工作量大， 早起错误后期测试才能发现
2、原型模型， 制定系统原型，适用前期需求不明确，随着开发进行更改开发实现，适应需求有变化。 优点： 得到比较好的需求定义， 有利于开发培训同步，开发费用低，开发周期短。
缺点： 过程不可见， 系统构造不合理， 需要使用特殊的开发工具。 客户端与开发理解不同，准确的原型设计困难。

3、增量模型， 使用已有产品升级
4、 螺旋模型， 增加风险分析阶段

软件危机的体现， 软件过程的阶段，软件开发模型

二章： 计算机系统工程
1、可行性分析从什么纬度进行分析， 什么是货币的时间价值？ 什么是投资回收期（在什么时刻可以把投资的金钱收回）

三章： 面向对象。
1、什么是面向对象？
2、什么是对象，什么是类？
3、UML，UML图形化表示方法
4、UML行为事物，分组事物，UML关系， （关联关系，泛化关系）

5、用例图，顺序图

四章： 软件需求工程
1、软件需求层次，各需求定义
2、软件需求分析方法（2种），各分析方法的详细介绍
3、数据流图，数据流图是分层的（顶层只有一个）
4、逻辑说明方式，程序说明、决策表、决策树

五章： 软件设计工程
1、概要设计（概要体系结构设计）、详细设计（详细算法设计）
2、模块化划分（内聚性、耦合性）
3、内聚类型（功能内聚）， 耦合性（内容耦合、公共耦合、控制耦合、标记耦合、etc）
4、软件设计方法（结构化设计方法），变换型
5、详细设计方式（N-S图，程序流程图、问题分析图）

八章：
1、测试生存周期模型， 测试阶段介绍（单元测试、集成测试）
2、度量方法（环形复杂度计算方式）
九章： 测试用例
1、白盒测试、黑盒测试
2、判定条件覆盖

10个选择、10个判断、6个大题（所有作业题）
作业1： 计算时间价值题
作业2： 图书管理系统功能性需求
四章大题： 借书还书用例图（ppt）

奇校验：这串序列1的个数如果为偶数则在前面加个1，使1的个数变成奇数，否则加0。
偶校验：这串序列1的个数如果为奇数则在前面加个1，使1的个数变成偶数，否则加0。

### 1.算出校验位数k[#](https://www.cnblogs.com/godoforange/p/12003676.html#701501076)

正常情况下我们需要如下此操作：

2^k >= k + 数据位数 + 1

这里等于3

### 2.确定校验位在海明码中的位置[#](https://www.cnblogs.com/godoforange/p/12003676.html#3334725185)

这里按2^k次幂留出来，就像1，2，4，8，16，32。（如果问有5位等其他烦人的数据位怎么办后面我会说，先按4位数做）

| H7   | H6   | H5   | H4   | H3   | H2   | H1   |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1    | 1    | 0    |      | 0    |      |      |

### 3.分组（重点，很多人蒙圈就在此）[#](https://www.cnblogs.com/godoforange/p/12003676.html#2898886050)

我们需要确认H1,H2,H4这三个校验位都来校验哪些位置。
我们按这个规则进行分配。

将1,2,4（海明码下标为1,2,4）[#](https://www.cnblogs.com/godoforange/p/12003676.html#3720296683)

的二进制码写出来，并且最高位补到3位(前面算的K数)
如下所示：

| 1    | 2    | 4    |
| :--- | :--- | :--- |
| 001  | 010  | 100  |

然后我们将0替换为*，作为通配表。[#](https://www.cnblogs.com/godoforange/p/12003676.html#433848599)

| 1    | 2    | 4    |
| :--- | :--- | :--- |
| **1  | *1*  | 1**  |

我们将1到7的二进制序列，列出来如下表[#](https://www.cnblogs.com/godoforange/p/12003676.html#1188401391)

| 7    | 6    | 5    | 4    | 3    | 2    | 1    |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 111  | 110  | 101  | 100  | 011  | 010  | 001  |

！！！重点！！！！[#](https://www.cnblogs.com/godoforange/p/12003676.html#2486330842)

我们将7->1依次与上面的通配表进行匹配

| 1        | 2        | 4        |
| :------- | :------- | :------- |
| **1      | *1*      | 1**      |
| 001（1） | 010（2） | 100（4） |
| 011（3） | 011（3） | 101（5） |
| 101（5） | 110（6） | 110（6） |
| 111（7） | 111（7） | 111（7） |

因此我们可以确定
H1 负责 1 3 5 7 位数的校验
H2 负责 2 3 6 7 位数的校验
H4 负责 4 5 6 7 位数的校验

### 4.求出校验位是0还是1[#](https://www.cnblogs.com/godoforange/p/12003676.html#3686537344)

因为上面我们得出以下结论：

H1 负责 1 3 5 7 位数的校验
H2 负责 2 3 6 7 位数的校验
H4 负责 4 5 6 7 位数的校验

那 根据

| H7   | H6   | H5   | H4   | H3   | H2   | H1   |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1    | 1    | 0    |      | 0    |      |      |

这张表，我们根据偶校验很容易就求出以下结论：
H3,H5,H7 1的个数为奇数 因此H1=1
H3,H6,H7 1的个数为偶数 因此H2=0
H5,H6,H7 1的个数为偶数 因此H4=0
至此我们得出了完整的汉明码

| H7   | H6   | H5   | H4   | H3   | H2   | H1   |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1    | 1    | 0    | 0    | 0    | 0    | 1    |

### 5.查错[#](https://www.cnblogs.com/godoforange/p/12003676.html#2451324380)

查错比较简单，如果以下三组
既
H1,H3,H5,H7
或者
H2,H3,H6,H7
或者
H4,H5,H6,H7
偶校验出错，则出错。

比方说 如果 H1,H3,H5,H7由1100 变成了 1110 （1的个数为偶数）就是出错了

10min 10 条

立即寻址-指令中直接给出操作数

指令中的形式地址字段为操作数

2）隐含寻址

*寄存器

3）直接寻址

4）间接寻址

5）存储器直接寻址

6）寄存器简介寻址

7）相对寻址

8）变址寻址

9）基址寻址

10）段寻址和复合寻址

十进制转二进制 150 

方法为：十进制数除2取余法，即十进制数除2，余数为权位上的数，得到的商值继续除2，依此步骤继续向下运算直到商为0为止。

二进制转十进制 10010110

方法为：把二进制数按权展开、相加即得十进制数。

二进制转八进制 10010110

方法为：3位二进制数按权展开相加得到1位八进制数。（注意事项，3位二进制转成八进制是从右到左开始转换，不足时补0）。

八进制转成二进制 226

方法为：八进制数通过除2取余法，得到二进制数，对每个八进制为3个二进制，不足时在最左边补零。

二进制转十六进制 1 0010 1100

方法为：与二进制转八进制方法近似，八进制是取三合一，十六进制是取四合一。（注意事项，4位二进制转成十六进制是从右到左开始转换，不足时补0）。

十六进制转二进制 12C

方法为：十六进制数通过除2取余法，得到二进制数，对每个十六进制为4个二进制，不足时在最左边补零。

1. 十进制转八进制或者十六进制有两种方法

   第一：间接法—把十进制转成二进制，然后再由二进制转成八进制或者十六进制。这里不再做图片用法解释。

2. 2

   第二：直接法—把十进制转八进制或者十六进制按照除8或者16取余，直到商为0为止。

八进制或者十六进制转成十进制

方法为：把八进制、十六进制数按权展开、相加即得十进制数。

八进制与十六进制之间的转换有两种方法

第一种：他们之间的转换可以先转成二进制然后再相互转换。

第二种：他们之间的转换可以先转成十进制然后再相互转换。

