## IEEE754浮点数

# 前言

　　Go语言之父Rob Pike大神曾吐槽：不能掌握正则表达式或浮点数就不配当码农！

> 　　You should not be permitted to write production code if you do not have an journeyman license in regular expressions or floating point math.

　　此前使用Java写Spark SQL业务时，也有遇到浮点数比较问题即x>70的记录行居然出现了70的记录，尽管SQL做了类型转换再比较也无济于事....

　　因此了解浮点数是很有必要的哟~~

# 什么是浮点数

　　电气和电子工程师协会IEEE对于计算机浮点数的存储、运算、表示等推出了IEEE754标准！

　　标准中规定：

　　　　float32位单精度浮点数在机器中表示用 1 位表示数字的符号，用 8 位表示指数，用 23 位表示尾数。

　　　　double64位双精度浮点数，用 1 位表示符号，用 11 位表示指数，52 位表示尾数。

　　　　其中指数域也称为阶码。浮点数存储字节定义如图：

　　    ![img](https://img2018.cnblogs.com/blog/826323/201906/826323-20190618095032673-328831084.png)

# 浮点数正规化

　　尾数不为0时，尾数域的最高有效位为1，这称为规格化。否则，以修改阶码同时左右移动小数点位置的办法，使其成为规格化数的形式。

　　浮点数x真值表示：

　　x=(−1)S×(1.M)×2e

　　float：　　　　e=E−127

　　double：　　  e=E−1023　

- S 符号位　　 0表示正 1表示负
- e 指数位 　　阶码E减去移码
- M 尾数位 　　二进制形式移码

# 移码

　　移码是真值补码的符号位取反，一般用作浮点数的阶码，目的是便于浮点数运算时的对阶操作。

　　对于定点整数，计算机一般采用补码的来存储。

　　正整数的符号位为0，反码和补码等同于原码。

　　负整数符号位都为1，原码，反码和补码的表示都不相同，由负数原码表示法变成反码和补码有如下规则：
　　（1）原码符号位为1不变，整数的每一位二进制数位求反得反码；
　　（2）反码符号位为1不变，反码数值位最低位加1得补码。

　　　比如，以一个字节来表示-3，那么[−3]原=10000011 [−3]反=11111100 [−3] 补=11111101 [−3]移=01111101

https://blog.csdn.net/abc1137377326/article/details/101988313